---
title: kth-ancestor
titleBar: Намиране на k-ти предшественик
author: Виктор Василев
date: 2024-04-01T01:24
tags:
  - post
---
В тази тема ще разгледаме една от най-известните задачи, свързани с дървета, която може да се появи на интервю за работа или като подзадача в сферата на състезателното програмиране. Това е именно намиране на k-ти предшественик на връх на кореново дърво. Ще започнем от базовите неща — малко терминология, свързана с дърветата, и как да представим кореново дърво в паметта, ще минем през наивния алгоритъм, който решава тази задача, и най-накрая ще покажем техниката “двоично повдигане” (binary lifting), която е доста умна оптимизация на наивния алгоритъм.

## Терминология
**Дълбочина на връх** — отдалечеността на върха от корена на дървото;

**Баща на връх** — върхът, който е свързан с дадения връх и е <abbr title="С дълбочина, която е с единица по-малка"> директно над него </abbr>;

**Предшественик на връх** — произволен връх, до който можем да стигнем от дадения връх, движейки се само нагоре;

**k-ти предшественик на връх** — предшественик на дадения връх с дълбочина, която е с k по-малка.

Ето и едно примерно дърво, с което ще работим:

![Alt text](https://miro.medium.com/v2/resize:fit:640/format:webp/1*P_z5lDmPGt1Ymk8aLqXEdg.png)
*Тук например коренът на дървото е връх 1 и е с дълбочина 0. Връх 1 е и баща на върхове 2 и 3, които са с дълбочина 1. Някой от предшествениците на връх 9 са например върхове 8, 6 и 2. Връх 7 не е предшественик на връх 9, защото не можем да стигнем до него, движейки се само нагоре. Вторият предшественик на връх 10 е връх 8, а третия предшественик на връх 2 не съществува.*

## Представяне на дървото в паметта
Ще представим дървото в паметта чрез едномерен масив parent[n + 1], където n е броят върхове на дървото. Размерът е с единица по-голям за удобство, защото нямаме връх 0, а останалите върхове са в интервала [1, n]. В този масив ще пазим кой е бащата на всеки от върховете, като бащата на корена ще -1 (не съществува). Ето как изглежда представянето на дървото, изобразено отгоре, чрез програмен код:
```cpp
parent[1] = -1;
parent[2] = 1;
parent[3] = 1;
parent[4] = 2;
parent[5] = 2;
parent[6] = 2;
parent[7] = 3;
parent[8] = 6;
parent[9] = 8;
parent[10] = 9;
```
## Наивен алгоритъм
Може би вече сте се сетили как би се решила задачата ни. За да намерим k-тия предшественик на даден връх, ще се движим нагоре по дървото, а това става много лесно поради начина, по който го пазим в паметта. Ето и реализацията на алгоритъма:
```cpp
int findKthAncestor(int node, int k) 
{
  for (int i = 0; i < k; i++)
  {
      // Движим се нагоре по бащите
      node = parent[node];
      // Ако сме стигнали "бащата" на корена, няма валидно решение
      if (node == -1)
      {
          break;
      }
  }
  return node;
}
```
Сложността на алгоритъма очевидно е **O(k)**, тоест е линейна.
На пръв поглед изглежда добре, но нека добавим един елемент в задачата ни, която драстично ще забави горния алгоритъм. Какво ако имаме **Q** на брой заявки, всяка от която пита за k-тия предшественик на някой от върховете на дървото? Тогава сложността става **O(Qk)**. Ако комбинираме тази сложност с факта, че ограниченията ни може да са много високи или пък дървото ни да <abbr title="Тоест е една права линия"> наподобява повече свързан списък </abbr>, нещата стават страшни.
## Умен алгоритъм чрез двоично повдигане
Почти винаги, когато имаме линейна сложност и искаме да я подобрим, търсим вариант, в който я намаляме до логаритмична. Това означава, че вместо да се движим с един връх нагоре, трябва да измислим начин, чрез който с една стъпка да се “повдигнем” до връх, който е доста по-нагоре. И в крайна сметка не ни интересува през какви върхове преминаваме (или пропускаме). Интересува ни крайната цел, а именно k-тия предшественик.
### Заигравка със степените на двойката
Логаритмичната сложност винаги е предпоставка да мислим за някакъв трик чрез степените на двойката. И нашият случай не е изключение. В основата на всичко е фактът, че всяко десетично число може да се представи <abbr title="Всъщност точно на това се основава и двоичната бройна система">**като сума от степени на двойката**</abbr>. Например, нека ни питат за 7-мия предшественик. Очевидно, 7 = 4 + 2 + 1 = 2² + 2¹ + 2⁰. Тоест, ако можем да се “повдигнем” нагоре по дървото първо с 4 върха, после с 2 и накрая с 1, намираме отговора на задачата в 3 стъпки, вместо в 7. Всъщност, дали ще се повдигнем нагоре първо с 4 или първо с 2 стъпки, няма никакво значение. Важното е стъпките да са точно тези и че са точно 3. Тази техника се нарича **двоично повдигане (binary lifting)**.
### Същност на двоичното повдигане
Добре де, за да се повдигнем нагоре с 2ⁿ върха от даден връх с константна сложност, то трябва някак си да помним за всеки връх кои са му 2ⁿ-тите предшественици, а сега знаем само кои са му <abbr title="Тоест бащите">2⁰-ите предшественици</abbr>.
```plaintext
Нека имаме двумерен масив up[v][k], който показва кой е k-тия предшественик на връх v, където k е точна степен на двойката. Тогава в базовия случай имаме up[v][1] = parent[v]. И наистина, 1-вия предшественик на произволен връх v е баща му. В най-общия случай имаме up[v][k] = up[up[v][k / 2]][k / 2]. Но какво по дяволите означава това? Всичко става ясно, ако отново се върнем към нашето примерно дърво:
```
![Alt text](https://miro.medium.com/v2/resize:fit:640/format:webp/1*P_z5lDmPGt1Ymk8aLqXEdg.png)
```plaintext
Тук ако питаме за 4-тия предшественик на връх 10, това очевидно е връх 2. Ако заместим във формулата получаваме следното: up[10][4] = up[up[10][2]][2]. Всъщност тя ни казва, че за да намерим 4-тия предшественик на връх 10 (up[10][4]), то трябва да намерим 2-рия предшественик на връх 10 (up[10][2], или връх 8) и за въпросния връх 8 намираме кой е 2-рия му предшественик (up[up[10][2]][2], или връх 2). С други думи, k-тия предшественик на връх v е k / 2-рия предшественик на k / 2-рия предшественик на връх v. Това на пръв поглед изглежда объркващо, но когато човек се замисли и осъзнае, че up[v][k] е някакъв връх и че v отново е някакъв връх по дефиниция, вече се разбира как работят тези “вложени” up-ове.
```
### Оптимизация на паметта
```plaintext
Казахме, че в масива ни up[v][k] числото k е точна степен на двойката. Какво става обаче със стойността в up[v][3] например? За тази клетка се отделя памет, но никога не се използва. Всъщност се оказва, че нашата таблица със стойности е изключително рядка (само малко стойности в нея са използваеми). Тогава нека да модифицираме второто измерение на масива по подходящ начин. Отново имаме масива up[v][k], но този път той ще показва кой е 2ᵏ-тия предшественик на върха v. Така не пазим самата степен на двойката, а само нейния степенен показател. Умно, а? Така вече получаваме up[v][0] = parent[v], тоест имаме, че 2⁰-вия (първия) предшественик на v е бащата на v. Също up[v][k] = up[up[v][k - 1]][k - 1], защото вече работим със степенния показател, а степенния показател минус единица по същество е деление на 2 в нашия случай.
```
### Имплементация на алгоритъма
Сега остана само предварително изчисляване на масива up. Една малка особеност, която трябва да се съобрази е колко е най-голямата степен на двойката, която ще ни потрябва. В най-лошия случай, ако дървото е една права линия с v върха, ще ни потрябват log2(v) степени на двойката (защото v = 2ˡᵒᵍ²⁽ᵛ⁾). Изчисляваме броя степени на двойката по следния начин:
```cpp
int log = 0;
while ((1 << log) <= v)
{
    log++;
}
```
```plaintext
Така получаваме размерите на масива up[v][log]. Сега е време да го попълним със стойности по правилата, за които говорихме по-рано:
```
```cpp
void precompute()
{
  for (int i = 1; i <= v; i++)
  {
      up[i][0] = parent[i];
      for (int j = 1; j < log; j++)
      {
          up[i][j] = up[up[i][j - 1]][j - 1];
      }
  }
}
```
```plaintext
Горният код работи, защото преди изчислението на up[i][j], заради начина, по който въртим циклите, имаме вече изчислена клетката up[i][j - 1] и можем да я използваме. Още повече, up[up[i][j - 1]][j - 1] също вече е изчислена.
```
Всъщност това не е нищо по-различно от **итеративно динамично програмиране**. Сложността е **O(v*log(v))**.

Добре, имаме си попълнен масива с нужната информация. Сега само трябва да отговаряме на заявките бързо. Нека се върнем на първоначалната идея — представяне на числото като сума от степени на двойката. За да знаем къде трябва да се повдигнем е нужно просто да погледнем двоичния запис на k-то, за което ни питат. Нека k = 6, тоест k = 110₂. Най-младшият бит е 0, тоест не трябва да се повдигаме нагоре с 2⁰ = 1, следващият наляво е 1, тоест трябва да се повдигнем нагоре с 2¹ = 2 и накрая трябва да се повдигнем нагоре и с 2² = 4. Ето и програмния код:
```cpp
int findKthAncestor(int node, int k)
{
  for (int i = 0; i < log; i++)
  {
    if (k & (1 << i)) 
    {
      // Повдигаме се нагоре с 2^i върха
      node = up[node][i];
    }
  }
  return node;
}
```
Сложността на този програмен фрагмент е **O(log(v))**. Като вземем предвид и сложността на предварителното изчисление на масива (**O(vlog(v)**) следва, че общата такава е **O(vlog(v) + Qlog(v))** или **O(log(v)(v + Q))**, където **Q** е броят на заявките. Това е много по-добре от **O(Qv)**.
## Заключение
С няколко наблюдения успяхме да имплементираме ефективен алгоритъм, който решава задачата за намиране на k-ти предшественик на връх на дърво. Само имайте предвид, че не се допускат върхове с по-голям номер да са предшественици на такива с по-малък. Иначе цялото попълване на масива ни няма да сработи и резултатите ще са странни. Надявам се да ви е било полезно!

